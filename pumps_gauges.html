<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pumps Gauges • Ranhill IIoT 3D</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f172a; --text:#e5e7eb; --muted:#94a3b8;
    --ok:#22c55e; --warn:#fbbf24; --bad:#ef4444; --ring:#1f2937;
    --chip:#111827; --chip-b:#2c3444;
    --tileH: 248px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background:radial-gradient(1200px 800px at 20% 10%,#0d1630,#0b1220 60%),var(--bg);
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    color:var(--text);
  }

  #topbar{position:sticky;top:0;z-index:40;display:flex;align-items:center;justify-content:space-between;
    gap:10px;padding:10px 16px;background:rgba(2,6,23,.78);backdrop-filter:blur(6px);border-bottom:1px solid rgba(148,163,184,.18)}
  #brand{font-weight:800;letter-spacing:.3px}
  .actions{display:flex;gap:8px;align-items:center}
  .btn{border:0;padding:8px 12px;border-radius:10px;background:#1f2937;color:var(--text);cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.28)}
  #liveBadge{font-size:12px;padding:4px 8px;border-radius:999px;background:transparent;border:1px solid rgba(148,163,184,.35);color:#cbd5e1}
  #liveBadge.ok{color:var(--ok);border-color:var(--ok)}
  #liveBadge.bad{color:var(--bad);border-color:var(--bad)}

  #filters{display:flex;gap:8px;flex-wrap:wrap;padding:10px 16px}
  select,input[type="search"]{background:#0f172a;color:var(--text);border:1px solid rgba(148,163,184,.3);
    border-radius:10px;padding:8px 10px}

  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(360px,1fr));gap:14px;padding:10px 16px 28px}
  .card{
    background:var(--card);border:1px solid rgba(148,163,184,.2);
    border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.32);
    min-height:var(--tileH);display:flex;flex-direction:column;
  }
  .card[data-sev="OK"]   {outline:2px solid rgba(34,197,94,.22)}
  .card[data-sev="WARN"] {outline:2px solid rgba(251,191,36,.20)}
  .card[data-sev="BAD"]  {outline:2px solid rgba(239,68,68,.22)}
  .card[data-sev="OFF"]  {outline:1px dashed rgba(148,163,184,.22)}

  .head{display:flex;align-items:center;justify-content:space-between;gap:10px;min-height:46px}
  .id{font-weight:700}
  .sub{font-size:12px;color:var(--muted)}
  .badges{display:flex;gap:6px;align-items:center;flex-wrap:wrap}

  .pill{display:inline-flex;align-items:center;gap:6px;height:24px;padding:0 10px;border-radius:999px;
    border:1px solid rgba(148,163,184,.28);font-size:12px;color:#cbd5e1;background:#0f172a}
  .pill.sev-ok   {background:rgba(34,197,94,.12);  border-color:rgba(34,197,94,.35);  color:#86efac}
  .pill.sev-warn {background:rgba(251,191,36,.10); border-color:rgba(251,191,36,.35); color:#fde68a}
  .pill.sev-bad  {background:rgba(239,68,68,.12);  border-color:rgba(239,68,68,.38);  color:#fca5a5}
  .pill.sev-off  {background:rgba(148,163,184,.10);border-color:rgba(148,163,184,.28);color:#cbd5e1}

  .row{display:flex;gap:16px;align-items:flex-end;justify-content:space-between;margin-top:6px}
  .gwrap{display:flex;gap:14px;align-items:center}
  .g{width:158px;height:108px;position:relative}
  .g svg{display:block;width:100%;height:100%}
  .g .centerV{position:absolute;left:0;right:0;top:38%;text-align:center;font-weight:800}
  .g .unit{position:absolute;left:0;right:0;top:60%;text-align:center;font-size:11px;color:var(--muted)}
  .g .minLbl{position:absolute;left:2px;bottom:2px;font-size:10px;color:var(--muted)}
  .g .maxLbl{position:absolute;right:2px;bottom:2px;font-size:10px;color:var(--muted)}
  .g .needle{transform-origin:50% 100%;transition:transform .25s ease}

  .chips{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--chip-b);padding:6px 8px;border-radius:10px;font-size:12px;color:#cbd5e1}

  .gear{border:0;background:#1f2937;color:#cbd5e1;width:28px;height:28px;border-radius:8px;cursor:pointer}
  .gear:hover{filter:brightness(1.1)}

  #modal{position:fixed;inset:0;background:rgba(2,6,23,.80);display:none;align-items:center;justify-content:center;z-index:60}
  #dlg{background:#0f172a;border:1px solid rgba(148,163,184,.25);border-radius:12px;padding:14px;min-width:320px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  #dlg h3{margin:0 0 10px}
  #dlg .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  #dlg label{font-size:12px;color:#cbd5e1}
  #dlg input{background:#0b1220;border:1px solid rgba(148,163,184,.35);color:#e5e7eb;border-radius:8px;padding:8px;width:100%}
  #dlg .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
  #dlg .btn{background:#1f2937}

  footer{padding:8px 16px 16px;color:#9aa3b2;font-size:12px}
</style>
</head>
<body>
<script>
(function(){
  try{
    const s = JSON.parse(localStorage.getItem('sessionV1')||'null');
    if(!s || !s.exp || Date.now() > s.exp){
      const next = encodeURIComponent(location.pathname + location.search + location.hash);
      location.replace('./login.html?next=' + next);
    }
  }catch(e){
    const next = encodeURIComponent(location.pathname + location.search + location.hash);
    location.replace('./login.html?next=' + next);
  }
})();
</script>

<div id="topbar">
  <div id="brand">RANHILL • Pumps Gauges</div>
  <div class="actions">
    <span id="liveBadge">LIVE: idle</span>
    <button class="btn" id="btnBack">Back to 3D</button>
    <button class="btn" id="btnLogout">Logout</button>
  </div>
</div>

<div id="filters">
  <select id="fFloor">
    <option value="">ทุกชั้น</option><option>F1</option><option>F2</option>
  </select>
  <select id="fRoom"><option value="">ทุกห้อง</option></select>
  <input id="fText" type="search" placeholder="ค้นหา ID เช่น F1-R1-P1">
  <span style="color:#9aa3b2;font-size:12px">* LIVE จาก WebSocket</span>
</div>

<div id="grid" class="grid"></div>
<footer><span class="muted">เกจสไตล์ Blynk + เข็ม • ตั้งค่า min/max แยกรายตัว (จำค่าไว้) • สุขภาพอิง AI (ช่วง + ค่าเฉลี่ย/ส่วนเบี่ยงเบน)</span></footer>

<!-- Modal ตั้งค่า -->
<div id="modal">
  <div id="dlg">
    <h3>ตั้งค่าเกจ · <span id="dlgId"></span></h3>
    <div style="margin-bottom:8px;color:#9aa3b2;font-size:12px">ตั้งค่าช่วงอ่านค่า (Min/Max)</div>
    <div style="margin-bottom:8px">
      <div style="font-weight:700;margin-bottom:4px">Amp (A)</div>
      <div class="row">
        <label>Min<input type="number" step="0.1" id="ampMin"></label>
        <label>Max<input type="number" step="0.1" id="ampMax"></label>
      </div>
    </div>
    <div>
      <div style="font-weight:700;margin-bottom:4px">Flow (L/min)</div>
      <div class="row">
        <label>Min<input type="number" step="1" id="flowMin"></label>
        <label>Max<input type="number" step="1" id="flowMax"></label>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="dlgCancel">Cancel</button>
      <button class="btn" id="dlgSave">Save</button>
    </div>
  </div>
</div>

<script type="module">
  async function resolveWS(){
    const params = new URLSearchParams(location.search);
    let url = params.get('ws') || localStorage.getItem('wsEndpoint');
    if(!url){
      try{
        const cfg = await fetch('./config.json?v='+Date.now(), {cache:'no-store'}).then(r=>r.json());
        url = cfg.ws;
      }catch(e){ console.warn('No/Bad config.json', e); }
    }
    if(url && location.protocol==='https:' && url.startsWith('ws://')){
      url = 'wss://' + url.slice(5);
    }
    if(url) localStorage.setItem('wsEndpoint', url);
    return url;
  }

  const PLAN_ROOMS=[
    [{x:-14,z:5,w:18,d:12},{x:2,z:5,w:14,d:12},{x:16,z:5,w:14,d:12},{x:-6,z:-6,w:16,d:10},{x:12,z:-6,w:18,d:10}],
    [{x:-14,z:5,w:18,d:12},{x:2,z:5,w:14,d:12},{x:16,z:5,w:14,d:12},{x:-6,z:-6,w:16,d:10},{x:12,z:-6,w:18,d:10}]
  ];
  const FLOORS = [];
  PLAN_ROOMS.forEach((rooms,idx)=>{
    const floorId= idx===0? 'F1':'F2';
    const floor={id:floorId, rooms:[]};
    rooms.forEach((r,ri)=>{
      const count=(r.w*r.d>260)?3:2;
      const room={id:`R${ri+1}`, pumps:[]};
      for(let i=0;i<count;i++) room.pumps.push(`${floorId}-R${ri+1}-P${i+1}`);
      floor.rooms.push(room);
    });
    FLOORS.push(floor);
  });
  const PUMP_IDS = FLOORS.flatMap(f=> f.rooms.flatMap(r=> r.pumps));

  const grid = document.getElementById('grid');
  const liveBadge = document.getElementById('liveBadge');
  const fFloor = document.getElementById('fFloor');
  const fRoom  = document.getElementById('fRoom');
  const fText  = document.getElementById('fText');

  function allRoomsOf(floorId){
    const floor = FLOORS.find(f=>f.id===floorId);
    return floor ? floor.rooms.map(r=>r.id) : [];
  }
  function rebuildRoomFilter(){
    const v = fFloor.value;
    const rooms = v ? allRoomsOf(v) : FLOORS.flatMap(f=>f.rooms.map(r=>r.id));
    fRoom.innerHTML = '<option value="">ทุกห้อง</option>' + rooms.map(r=>`<option>${r}</option>`).join('');
  }
  fFloor.addEventListener('change', ()=>{ rebuildRoomFilter(); render(); });
  fRoom .addEventListener('change', render);
  fText .addEventListener('input', render);
  rebuildRoomFilter();

  /* --------- per-pump config --------- */
  let gaugeCfg = {};
  try{ gaugeCfg = JSON.parse(localStorage.getItem('gaugeCfgV1')||'{}') || {}; }catch(e){}
  function getCfg(id){
    const d = gaugeCfg[id] || {};
    return {
      minAmp:  d.minAmp  ?? 0,
      maxAmp:  d.maxAmp  ?? 15,
      minFlow: d.minFlow ?? 0,
      maxFlow: d.maxFlow ?? 220,
    };
  }
  function saveCfg(id, cfg){
    gaugeCfg[id] = {...getCfg(id), ...cfg};
    try{ localStorage.setItem('gaugeCfgV1', JSON.stringify(gaugeCfg)); }catch(e){}
  }

  /* ---------- “AI” health (ช่วง + cohort stats) ---------- */
  const ARC_LEN = Math.PI*90;
  const state = {};                // id -> {enabled, amp, flow}
  let cohort = {mA:0,sA:0,mF:0,sF:0,n:0};  // mean/std ของปั๊มที่ RUN

  function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }
  function ratio(v,min,max){ return (clamp(v,min,max)-min)/Math.max(1e-6,(max-min)); }
  function angleDeg(v,min,max){ return -90 + ratio(v,min,max)*180; }
  function colorForSev(sev){ return sev==='BAD'? '#ef4444' : sev==='WARN'? '#fbbf24' : '#22c55e'; }

  function recomputeCohort(){
    const rows = Object.entries(state).map(([id,s])=>({id,...s})).filter(r=>r.enabled && isFinite(r.amp) && isFinite(r.flow));
    const n = rows.length;
    if(!n){ cohort={mA:0,sA:0,mF:0,sF:0,n:0}; return; }
    const mA = rows.reduce((a,r)=>a+ +r.amp,0)/n;
    const mF = rows.reduce((a,r)=>a+ +r.flow,0)/n;
    const sA = Math.sqrt(rows.reduce((a,r)=>a+Math.pow(+r.amp-mA,2),0)/n);
    const sF = Math.sqrt(rows.reduce((a,r)=>a+Math.pow(+r.flow-mF,2),0)/n);
    cohort = {mA,sA,mF,sF,n};
  }

  // กติกา:
  // - ใช้สัดส่วนช่วงของเกจ (R) + z-score จาก cohort
  // - BAD: (กระแสสูงมาก หรือ zA>1.5) ร่วมกับ (โฟลว์ต่ำมาก หรือ zF>1.0)
  // - WARN: อย่างใดอย่างหนึ่งเข้าโซนเตือน, หรือ pattern เซนเซอร์ผิดปกติ
  function severityOf(id, s){
    if(!s || !s.enabled) return 'OFF';
    const cfg = getCfg(id);
    const R_A = ratio(+s.amp,  cfg.minAmp,  cfg.maxAmp);  // 0..1
    const R_F = ratio(+s.flow, cfg.minFlow, cfg.maxFlow); // 0..1 (ยิ่งต่ำยิ่งน่าห่วง)
    const zA  = cohort.sA>0 ? (+s.amp - cohort.mA)/cohort.sA : 0; // สูง + คือกระแสสูงกว่ากลุ่ม
    const zF  = cohort.sF>0 ? (cohort.mF - +s.flow)/cohort.sF : 0; // สูง + คือโฟลว์ต่ำกว่ากลุ่ม

    const overCurrHard = R_A >= 0.90;           // ≥90% ของช่วงเกจ
    const overCurrSoft = R_A >= 0.75;
    const overCurrZBad = zA > 1.5;
    const overCurrZWrn = zA > 0.8;

    const lowFlowHard  = R_F <= 0.10;           // ≤10% ของช่วง
    const lowFlowSoft  = R_F <= 0.25;
    const lowFlowZBad  = zF > 1.0;
    const lowFlowZWrn  = zF > 0.6;

    // sensor anomaly: กระแสเกือบ 0 แต่มีโฟลว์
    const sensorSusp   = (R_A < 0.02 && R_F > 0.2);

    if( (overCurrHard||overCurrZBad) && (lowFlowHard||lowFlowZBad) ) return 'BAD';
    if( overCurrHard || lowFlowHard ) return 'BAD';
    if( (overCurrSoft||overCurrZWrn) && (lowFlowSoft||lowFlowZWrn) ) return 'BAD'; // รวมเสี่ยงสองด้าน
    if( overCurrSoft||overCurrZWrn||lowFlowSoft||lowFlowZWrn||sensorSusp ) return 'WARN';
    return 'OK';
  }

  /* ---------- UI building ---------- */
  let visibleIds = []; // ids ที่ render อยู่ตอนนี้

  function gaugeHTML(id, kind){
    const gid = `${kind}-${id}`;
    return `
      <div class="g" id="g-${gid}">
        <svg viewBox="0 0 100 60" aria-hidden="true">
          <path d="M10,50 A40,40 0 0 1 90,50" stroke="#2b3546" stroke-width="10" fill="none" stroke-linecap="round"/>
          <path id="arc-${gid}" d="M10,50 A40,40 0 0 1 90,50" stroke="#22c55e" stroke-width="10" fill="none" stroke-linecap="round" stroke-dasharray="0 ${ARC_LEN}"/>
          <g id="needle-${gid}" class="needle" transform="rotate(-90 50 50)">
            <line x1="50" y1="50" x2="50" y2="16" stroke="white" stroke-width="2"/>
            <circle cx="50" cy="50" r="3" fill="#e5e7eb"/>
          </g>
        </svg>
        <div class="centerV" id="v-${gid}">0</div>
        <div class="unit">${kind==='amp'?'Amp':'Flow'}</div>
        <div class="minLbl" id="min-${gid}">0</div>
        <div class="maxLbl" id="max-${gid}">0</div>
      </div>`;
  }

  function cardHTML(id){
    const [floor, room] = id.split('-').slice(0,2);
    const cfg = getCfg(id);
    return `<div class="card" id="card-${id}" data-sev="OFF">
      <div class="head">
        <div>
          <div class="id">${id}</div>
          <div class="sub">${floor}/${room}</div>
        </div>
        <div class="badges">
          <span class="pill" id="run-${id}">—</span>
          <span class="pill sev sev-off" id="sev-${id}">OFF</span>
          <span class="pill" id="chipA-${id}">Amp 0.0 A</span>
          <span class="pill" id="chipF-${id}">Flow 0 L/min</span>
          <button class="gear" id="gear-${id}" title="ตั้งค่า">⚙</button>
        </div>
      </div>

      <div class="row">
        <div class="gwrap">
          ${gaugeHTML(id,'amp')}
          ${gaugeHTML(id,'flow')}
        </div>
      </div>

      <div class="chips" style="margin-top:auto">
        <span class="chip">Amp: <b id="ka-${id}" style="margin-left:6px">0.0</b> A</span>
        <span class="chip">Flow: <b id="kf-${id}" style="margin-left:6px">0</b> L/min</span>
        <span class="chip">ช่วง: <b id="rng-${id}" style="margin-left:6px">${cfg.minAmp}-${cfg.maxAmp}A / ${cfg.minFlow}-${cfg.maxFlow}L</b></span>
      </div>
    </div>`;
  }

  function render(){
    const q = (fText.value||'').trim().toLowerCase();
    const ff = fFloor.value, rr = fRoom.value;
    const ids = PUMP_IDS.filter(id=>{
      if(q && !id.toLowerCase().includes(q)) return false;
      if(ff && !id.startsWith(ff+'-')) return false;
      if(rr && !id.includes('-'+rr+'-')) return false;
      return true;
    });
    visibleIds = ids.slice();
    grid.innerHTML = ids.map(cardHTML).join('');
    ids.forEach(id=>{
      document.getElementById('gear-'+id)?.addEventListener('click', ()=> openSettings(id));
      applyMinMaxLabels(id);
      applyStateToCard(id, state[id]||null);
    });
  }

  function applyMinMaxLabels(id){
    const cfg = getCfg(id);
    const ampMin = document.getElementById(`min-amp-${id}`);
    const ampMax = document.getElementById(`max-amp-${id}`);
    const flowMin = document.getElementById(`min-flow-${id}`);
    const flowMax = document.getElementById(`max-flow-${id}`);
    if(ampMin)  ampMin.textContent  = cfg.minAmp;
    if(ampMax)  ampMax.textContent  = cfg.maxAmp;
    if(flowMin) flowMin.textContent = cfg.minFlow;
    if(flowMax) flowMax.textContent = cfg.maxFlow;
    const rng = document.getElementById('rng-'+id);
    if(rng) rng.textContent = `${cfg.minAmp}-${cfg.maxAmp}A / ${cfg.minFlow}-${cfg.maxFlow}L`;
  }

  /* ---------- Modal ---------- */
  const modal = document.getElementById('modal');
  const dlgId = document.getElementById('dlgId');
  const ampMin = document.getElementById('ampMin');
  const ampMax = document.getElementById('ampMax');
  const flowMin= document.getElementById('flowMin');
  const flowMax= document.getElementById('flowMax');
  let editingId = null;

  function openSettings(id){
    editingId = id;
    const cfg = getCfg(id);
    dlgId.textContent = id;
    ampMin.value = cfg.minAmp;
    ampMax.value = cfg.maxAmp;
    flowMin.value= cfg.minFlow;
    flowMax.value= cfg.maxFlow;
    modal.style.display='flex';
  }
  document.getElementById('dlgCancel').addEventListener('click', ()=> modal.style.display='none');
  document.getElementById('dlgSave').addEventListener('click', ()=>{
    if(!editingId) return;
    const cfg = {
      minAmp:  parseFloat(ampMin.value),
      maxAmp:  parseFloat(ampMax.value),
      minFlow: parseFloat(flowMin.value),
      maxFlow: parseFloat(flowMax.value),
    };
    saveCfg(editingId, cfg);
    modal.style.display='none';
    applyMinMaxLabels(editingId);
    if(state[editingId]) applyStateToCard(editingId, state[editingId]);
  });
  modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

  /* ---------- Paint ---------- */
  function setHealthPill(id, sev){
    const el = document.getElementById('sev-'+id);
    if(!el) return;
    el.textContent = (sev==='OFF'?'OFF • STOP':sev);
    el.className = 'pill ' + (sev==='OK'?'sev-ok':sev==='WARN'?'sev-warn':sev==='BAD'?'sev-bad':'sev-off');
    const card = document.getElementById('card-'+id);
    if(card) card.setAttribute('data-sev', sev);
  }
  function setRunPill(id, enabled){
    const el = document.getElementById('run-'+id);
    if(!el) return;
    el.textContent = enabled? 'ON • RUN' : 'OFF • STOP';
    el.className = 'pill' + (enabled?'':' sev-off');
  }
  function paintGauge(id, kind, val, min, max, sev){
    const gid = `${kind}-${id}`;
    const p   = document.getElementById('arc-'+gid);
    const vn  = document.getElementById('v-'+gid);
    const ndl = document.getElementById('needle-'+gid);
    const minL= document.getElementById('min-'+gid);
    const maxL= document.getElementById('max-'+gid);

    if(minL) minL.textContent = min;
    if(maxL) maxL.textContent = max;
    if(!p || !vn || !ndl) return;

    if(val==null){
      p.setAttribute('stroke','#2b3546');
      p.setAttribute('stroke-dasharray', `0 ${ARC_LEN}`);
      vn.textContent='0';
      ndl.style.transform = `rotate(-90deg)`;
      return;
    }
    const r = ratio(val,min,max);
    const dash = clamp(r,0,1)*ARC_LEN;
    p.setAttribute('stroke', colorForSev(sev));
    p.setAttribute('stroke-dasharray', `${dash} ${ARC_LEN}`);
    vn.textContent = kind==='amp' ? (+val).toFixed(1) : Math.round(+val);
    ndl.style.transform = `rotate(${angleDeg(val,min,max)}deg)`;
  }

  function applyStateToCard(id, s){
    const card = document.getElementById('card-'+id);
    if(!card) return;
    const chipA= document.getElementById('chipA-'+id);
    const chipF= document.getElementById('chipF-'+id);
    const ka  = document.getElementById('ka-'+id);
    const kf  = document.getElementById('kf-'+id);

    if(!s){
      setRunPill(id,false); setHealthPill(id,'OFF');
      paintGauge(id,'amp',null,0,15,'OFF');
      paintGauge(id,'flow',null,0,220,'OFF');
      if(chipA) chipA.textContent='Amp 0.0 A';
      if(chipF) chipF.textContent='Flow 0 L/min';
      if(ka) ka.textContent='0.0'; if(kf) kf.textContent='0';
      return;
    }

    const cfg = getCfg(id);
    const amp  = +s.amp  || 0;
    const flow = +s.flow || 0;
    const enabled = !!s.enabled;
    const sev = severityOf(id, s);

    setRunPill(id, enabled);
    setHealthPill(id, sev);
    paintGauge(id,'amp',  enabled?amp:null,  cfg.minAmp,  cfg.maxAmp,  sev);
    paintGauge(id,'flow', enabled?flow:null, cfg.minFlow, cfg.maxFlow, sev);

    if(chipA) chipA.textContent = `Amp ${amp.toFixed(1)} A`;
    if(chipF) chipF.textContent = `Flow ${Math.round(flow)} L/min`;
    if(ka) ka.textContent = amp.toFixed(1);
    if(kf) kf.textContent = String(Math.round(flow));
  }

  /* ---------- Back & Logout ---------- */
  document.getElementById('btnBack').addEventListener('click', ()=>{
    const ref = document.referrer;
    try{ if(ref && new URL(ref).origin === location.origin){ history.back(); return; } }catch(e){}
    const q = new URLSearchParams(location.search);
    const ws = q.get('ws') || localStorage.getItem('wsEndpoint');
    const home = localStorage.getItem('home3D') || './index.html';
    const url = new URL(home, location.href);
    if(ws) url.searchParams.set('ws', ws);
    location.href = url.pathname + url.search;
  });
  document.getElementById('btnLogout').addEventListener('click', ()=>{
    try{ localStorage.removeItem('sessionV1'); }catch(e){}
    const next = encodeURIComponent('./pumps_gauges.html');
    location.href = './login.html?next=' + next;
  });

  /* ---------- WS live ---------- */
  const WS_URL = await resolveWS();
  console.log('WS endpoint:', WS_URL);
  let ws, wsTimer, backoff=2000;

  function setLive(state,text){
    liveBadge.classList.remove('ok','bad');
    if(state==='ok'){ liveBadge.classList.add('ok'); liveBadge.textContent='LIVE: connected'; }
    else if(state==='bad'){ liveBadge.classList.add('bad'); liveBadge.textContent='LIVE: disconnected'; }
    else liveBadge.textContent = text || 'LIVE: idle';
  }

  // หลังได้รับ update: อัปเดต state -> คำนวณ cohort -> repaint ทุกการ์ดที่แสดง
  function applyUpdate(msg){
    if(Array.isArray(msg)){ msg.forEach(applyUpdate); return; }
    const m = msg&&typeof msg==='object'?msg:null; if(!m||typeof m.id!=='string') return;
    if(!(m.id in state)) state[m.id] = {enabled:true, amp:0, flow:0};
    if(typeof m.enabled==='boolean') state[m.id].enabled = m.enabled;
    if(typeof m.amp==='number') state[m.id].amp = m.amp;
    if(typeof m.flow==='number') state[m.id].flow = m.flow;

    // คำนวณสถิติใหม่แล้ว repaint ทั้งชุดที่มองเห็น
    recomputeCohort();
    visibleIds.forEach(id=> applyStateToCard(id, state[id]||null));
  }

  function connectWS(){
    if(!WS_URL){ setLive(null,'LIVE: no ws configured'); return; }
    try{ ws=new WebSocket(WS_URL); }catch(e){ console.warn('WS construct error',e); setLive('bad'); return; }
    ws.onopen=()=>{ backoff=2000; setLive('ok'); console.log('WS connected'); };
    ws.onmessage=(ev)=>{ try{ const data=JSON.parse(ev.data); applyUpdate(data); }catch(e){ console.warn('WS parse fail',e); } };
    ws.onclose =()=>{ setLive('bad'); clearTimeout(wsTimer); wsTimer=setTimeout(connectWS, backoff); backoff=Math.min(backoff*1.8, 20000); };
    ws.onerror =(e)=> console.warn('WS error', e);
  }
  connectWS(); setInterval(()=>{ if(ws && ws.readyState===1) setLive('ok'); else setLive('bad'); },1000);

  /* ---------- Initial render ---------- */
  render();
  // เผื่อมี state ตั้งต้นจากที่อื่น เรียกคำนวณ cohort อีกครั้ง
  recomputeCohort();
</script>
</body>
</html>
